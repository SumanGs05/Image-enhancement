GAMMA CORRECTION-->>

function [ result ] = gammaCorrection(image, a, gamma)
image = im2double(image);
result = a * (image .^ gamma);
end

red compensate-->>


function ret = redCompensate( im, w )
a = 1;
r = im2double(im(:,:,1));
g = im2double(im(:,:,2));
b = im2double(im(:,:,3));
[height,width,~] = size(im);
padsize = [(w-1)/2,(w-1)/2];
padr = padarray(r, padsize, 'symmetric', 'both');
padg = padarray(g, padsize, 'symmetric', 'both');
ret = im;
for i = 1:height
    for j = 1:width
        slider = padr(i:i+w-1,j:j+w-1);
        slideg = padg(i:i+w-1,j:j+w-1);
        r_mean = mean(mean(slider));
        g_mean = mean(mean(slideg));
        Irc = r(i,j) + a * (g_mean - r_mean) * (1-r(i,j)) * g(i,j);
        Irc = uint8(Irc * 255);
        ret(i, j, 1) = Irc;
    end
end
end


sharpning-->>

function [ result ] = sharp(image)
image = im2double(image);
GaussKernel = fspecial('gaussian', 5, 3);
imBlur = imfilter(image,GaussKernel);
unSharpMask = image - imBlur;
stretchIm = hisStretching(unSharpMask);
result = (image + stretchIm)/2;
end


blue correction


function [ ret ] = blueCompensate( im )
im=im2double(im);
[M, N, ~]=size(im);
r=im(:,:,1);
g=im(:,:,2);
b=im(:,:,3);
meanB=mean(mean(b));
meanG=mean(mean(g));
for i=1:M
    for j=1:N
        b(i, j)=b(i, j)+(meanG-meanB)*(1-b(i, j))*g(i, j);
    end
end
ret(:,:,1)=r;
ret(:,:,2)=g;
ret(:,:,3)=b;
end


histogram stretching-->>

function [ result ] = hisStretching(image)
% Contrast stretching by histogram normalization
image = im2double(image);
[M, N, C] = size(image);
result = zeros(M, N, C);
for c = 1:C
    channel = image(:,:,c);
    minVal = min(channel(:));
    maxVal = max(channel(:));
    if maxVal > minVal
        result(:,:,c) = (channel - minVal) / (maxVal - minVal);
    else
        result(:,:,c) = channel;
    end
end
end


simple color balance-->>

function [ result ] = simple_color_balance(image)
% Simple white balance using Gray World assumption
image = im2double(image);
r = image(:,:,1);
g = image(:,:,2);
b = image(:,:,3);

% Calculate mean of each channel
mean_r = mean(r(:));
mean_g = mean(g(:));
mean_b = mean(b(:));

% Gray world assumption: average color should be gray
avg = (mean_r + mean_g + mean_b) / 3;

% Scale factors
scale_r = avg / mean_r;
scale_g = avg / mean_g;
scale_b = avg / mean_b;

% Apply scaling
result = image;
result(:,:,1) = min(r * scale_r, 1);
result(:,:,2) = min(g * scale_g, 1);
result(:,:,3) = min(b * scale_b, 1);
end


rgb to lab conversion-->>

function [ lab ] = rgb_to_lab(rgb)
% Convert RGB to LAB color space
lab = rgb2lab(rgb);
end


saliency detection-->>

function [ saliency ] = saliency_detection(image)
% Compute saliency map using spectral residual approach
image = im2double(image);
if size(image, 3) == 3
    grayImg = rgb2gray(image);
else
    grayImg = image;
end

% Spectral Residual
imgFFT = fft2(grayImg);
amplitude = abs(imgFFT);
phase = angle(imgFFT);

% Log spectrum
logAmplitude = log(amplitude + 1);

% Spectral residual
avgFilter = fspecial('average', 3);
spectralResidual = logAmplitude - imfilter(logAmplitude, avgFilter, 'replicate');

% Reconstruct
saliencyFFT = exp(spectralResidual + 1i * phase);
saliencyMap = abs(ifft2(saliencyFFT)).^2;

% Smooth with Gaussian
saliency = mat2gray(imgaussfilt(saliencyMap, 10));
end


saturation weight-->>

function [ saturation ] = Saturation_weight(image)
% Calculate saturation weight
image = im2double(image);
r = image(:,:,1);
g = image(:,:,2);
b = image(:,:,3);

% Saturation calculation
maxRGB = max(max(r, g), b);
minRGB = min(min(r, g), b);
saturation = (maxRGB - minRGB);
end


normalized weight-->>

function [W1, W2] = norm_weight(WL1, WS1, WSat1, WL2, WS2, WSat2)
% Normalize weights across two images
% Combine weights
W1 = (WL1 + WS1 + WSat1) + 0.1;  % Add small constant to avoid division by zero
W2 = (WL2 + WS2 + WSat2) + 0.1;

% Normalize
W_total = W1 + W2;
W1 = W1 ./ W_total;
W2 = W2 ./ W_total;
end


gaussian pyramid-->>

function [ pyramid ] = gaussian_pyramid(image, level)
% Build Gaussian pyramid
pyramid = cell(level, 1);
pyramid{1} = image;

for i = 2:level
    % Apply Gaussian filter and downsample
    smoothed = imgaussfilt(pyramid{i-1}, 1);
    pyramid{i} = impyramid(smoothed, 'reduce');
end
end


laplacian pyramid-->>

function [ pyramid ] = laplacian_pyramid(image, level)
% Build Laplacian pyramid
pyramid = cell(level, 1);
gaussian = cell(level, 1);
gaussian{1} = image;

% Build Gaussian pyramid first
for i = 2:level
    smoothed = imgaussfilt(gaussian{i-1}, 1);
    gaussian{i} = impyramid(smoothed, 'reduce');
end

% Build Laplacian pyramid
for i = 1:level-1
    % Expand the next level
    expanded = impyramid(gaussian{i+1}, 'expand');
    
    % Match sizes (expansion might create size mismatch)
    [M, N] = size(gaussian{i});
    [M_exp, N_exp] = size(expanded);
    if M_exp ~= M || N_exp ~= N
        expanded = imresize(expanded, [M, N]);
    end
    
    % Laplacian is difference
    pyramid{i} = gaussian{i} - expanded;
end
pyramid{level} = gaussian{level};
end


pyramid reconstruct-->>

function [ result ] = pyramid_reconstruct(pyramid)
% Reconstruct image from Laplacian pyramid
level = length(pyramid);
result = pyramid{level};

for i = level-1:-1:1
    % Expand the result
    expanded = impyramid(result, 'expand');
    
    % Match sizes
    [M, N] = size(pyramid{i});
    [M_exp, N_exp] = size(expanded);
    if M_exp ~= M || N_exp ~= N
        expanded = imresize(expanded, [M, N]);
    end
    
    % Add Laplacian level
    result = expanded + pyramid{i};
end
end


UIQM metric-->>

function [ uiqm_value ] = UIQM(image)
% Underwater Image Quality Measure
% Simplified version based on colorfulness, sharpness, and contrast
image = im2double(image);

% 1. Colorfulness (UICM)
r = image(:,:,1);
g = image(:,:,2);
b = image(:,:,3);
rg = r - g;
yb = (r + g) / 2 - b;
uicm = sqrt(mean(rg(:))^2 + mean(yb(:))^2) + 0.3 * sqrt(var(rg(:)) + var(yb(:)));

% 2. Sharpness (UISM)
gray = rgb2gray(image);
sobelX = [-1 0 1; -2 0 2; -1 0 1];
sobelY = sobelX';
edgeX = imfilter(gray, sobelX, 'replicate');
edgeY = imfilter(gray, sobelY, 'replicate');
uism = mean(sqrt(edgeX(:).^2 + edgeY(:).^2));

% 3. Contrast (UIConM)
gray_log = log(gray + 1);
uiconm = std(gray_log(:));

% Weighted combination
c1 = 0.0282; c2 = 0.2953; c3 = 3.5753;
uiqm_value = c1 * uicm + c2 * uism + c3 * uiconm;
end


UCIQE metric-->>

function [ uciqe_value ] = UCIQE(image)
% Underwater Color Image Quality Evaluation
image = im2double(image);

% Convert to CIELab
lab = rgb2lab(image);
L = lab(:,:,1);
a = lab(:,:,2);
b = lab(:,:,3);

% Chroma
chroma = sqrt(a.^2 + b.^2);

% Standard deviations
sigma_c = std(chroma(:));
sigma_l = std(L(:));

% Saturation
saturation = chroma ./ (sqrt(a.^2 + b.^2 + L.^2) + eps);
avg_sat = mean(saturation(:));

% UCIQE formula
c1 = 0.4680; c2 = 0.2745; c3 = 0.2576;
uciqe_value = c1 * sigma_c + c2 * sigma_l + c3 * avg_sat;
end